(this["webpackJsonplearn-cesium"]=this["webpackJsonplearn-cesium"]||[]).push([[12],{138:function(e,o,n){"use strict";n.r(o);o.default="\nprecision highp float;\nuniform vec4 u_baseColorFactor;\nuniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec3 u_emissiveFactor;\nvarying vec3 v_normal;\nvarying vec3 v_positionEC;\nconst float M_PI = 3.141592653589793;\n\nvec3 lambertianDiffuse(vec3 diffuseColor) {\n  return diffuseColor / M_PI;\n}\n\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) {\n  return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat smithVisibilityG1(float NdotV, float roughness) {\n  float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n  return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV) {\n  return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\nfloat GGX(float roughness, float NdotH) {\n  float roughnessSquared = roughness * roughness;\n  float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n  return roughnessSquared / (M_PI * f * f);\n}\n\nvec3 SRGBtoLINEAR3(vec3 srgbIn) {\n  return pow(srgbIn, vec3(2.2));\n}\n\nvec3 applyTonemapping(vec3 linearIn) {\n#ifndef HDR \n  return czm_acesTonemapping(linearIn);\n#else \n  return linearIn;\n#endif \n}\n\nvec3 LINEARtoSRGB(vec3 linearIn) {\n#ifndef HDR \n  return pow(linearIn, vec3(1.0 / 2.2));\n#else \n  return linearIn;\n#endif \n}\n\n#ifdef USE_IBL_LIGHTING \nuniform vec2 gltf_iblFactor; \n#endif \n#ifdef USE_CUSTOM_LIGHT_COLOR \n#endif \nvoid main(void) {\n  vec4 _baseColor = vec4(u_baseColorFactor.rgb, 1.);\n  vec3 ng = normalize(v_normal);\n  vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n  vec3 n = ng;\n  if(czm_backFacing()) {\n      n = -n;\n  }\n  vec4 baseColorWithAlpha = _baseColor;\n  vec3 baseColor = baseColorWithAlpha.rgb;\n  float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n  float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n  vec3 v = -normalize(v_positionEC);\n  vec3 lightColorHdr = _baseColor.rgb;\n  vec3 l = normalize(czm_lightDirectionEC);\n  vec3 h = normalize(v + l);\n  float NdotL = clamp(dot(n, l), 0.001, 1.0);\n  float NdotV = abs(dot(n, v)) + 0.001;\n  float NdotH = clamp(dot(n, h), 0.0, 1.0);\n  float LdotH = clamp(dot(l, h), 0.0, 1.0);\n  float VdotH = clamp(dot(v, h), 0.0, 1.0);\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n  vec3 specularColor = mix(f0, baseColor, metalness);\n  float alpha = roughness * roughness;\n  float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n  vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n  vec3 r0 = specularColor.rgb;\n  vec3 F = fresnelSchlick2(r0, r90, VdotH);\n  float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n  float D = GGX(alpha, NdotH);\n  vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n  vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n  vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\n#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n  vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n  float vertexRadius = length(positionWC);\n  float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n  float reflectionDotNadir = dot(r, normalize(positionWC));\n  r.x = -r.x;\n  r = -normalize(czm_temeToPseudoFixed * r);\n  r.x = -r.x;\n  float inverseRoughness = 1.04 - roughness;\n  inverseRoughness *= inverseRoughness;\n  vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n  float atmosphereHeight = 0.05;\n  float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n  float blendRegionOffset = roughness * -1.0;\n  float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n  float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n  float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n  float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n  vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n  vec3 nadirColor = belowHorizonColor * 0.5;\n  vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n  vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n  vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n  vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n  float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n  float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n  vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n  float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n  vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n  specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n  specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n#ifdef USE_SUN_LUMINANCE \n  float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n  float S = acos(LdotZenith);\n  float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n  float gamma = acos(NdotL);\n  float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n  float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith, 2.0)) * (1.0 - exp(-0.32));\n  float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n#endif \n  vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n  vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n  float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\n  vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\n  IBLColor *= lightColor;\n#ifdef USE_SUN_LUMINANCE \n  color += IBLColor * luminance;\n#else \n  color += IBLColor; \n#endif \n#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n  const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0);\n  vec3 cubeDir = normalize(yUpToZUp * gltf_iblReferenceFrameMatrix * normalize(reflect(-v, n))); \n#ifdef DIFFUSE_IBL \n#ifdef CUSTOM_SPHERICAL_HARMONICS \n  vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n#else \n  vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n#endif \n#else \n  vec3 diffuseIrradiance = vec3(0.0); \n#endif \n#ifdef SPECULAR_IBL \n  vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n#ifdef CUSTOM_SPECULAR_IBL \n  vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir, roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n#else \n  vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir, roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n#endif \n  specularIBL *= F * brdfLut.x + brdfLut.y;\n#else \n  vec3 specularIBL = vec3(0.0); \n#endif \n  color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n#endif \n  color += u_emissiveFactor;\n  color = applyTonemapping(color);\n  color = LINEARtoSRGB(color);\n\n  vec4 position = czm_inverseModelView * vec4(v_positionEC, 1.);\n\n  // Set color deep by height.\n  float deep = clamp((position.z - 50.) / 200. + .5, 0., 3.5);\n  vec4 post_color = _baseColor * vec4(vec3(deep) * 1.2, 1.0);\n\n  // Set scanning lines.\n  float time = fract(czm_frameNumber / (60. * 5.));\n  float scan = step(0.0015, abs(clamp(position.z / 650., 0., 1.) - time));\n\n  gl_FragColor = vec4(color * .1 + post_color.rgb * .7 + ((scan == 0. ? 5. : 1.) * post_color.rgb), 1.0);\n}\n"}}]);